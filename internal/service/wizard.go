package service

import (
	"bufio"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"smtptunnel/internal/certs"
	"smtptunnel/internal/crypto"
)

// RunServerWizard interactively generates a server configuration file.
func RunServerWizard() error {
	if err := EnsureDirectories(); err != nil {
		return err
	}

	reader := bufio.NewReader(os.Stdin)

	fmt.Println("=== SMTP Tunnel Server Configuration Wizard ===")
	fmt.Println()

	// Hostname
	hostname := prompt(reader, "Server hostname (e.g., mail.example.com)", "mail.example.com")

	// Listen address
	listen := prompt(reader, "Listen address", "0.0.0.0:587")

	// Log level
	logLevel := prompt(reader, "Log level (info/debug/warn)", "info")

	// --- Certificates ---
	fmt.Println()
	fmt.Println("--- TLS Certificates ---")
	certDir := filepath.Join(CertsDir, hostname)
	certFile := filepath.Join(certDir, "server.crt")
	keyFile := filepath.Join(certDir, "server.key")
	caCertFile := filepath.Join(certDir, "ca.crt")

	// Check if certs already exist
	certsExist := fileExists(certFile) && fileExists(keyFile)
	if certsExist {
		fmt.Printf("Certificates already exist in %s\n", certDir)
		useExisting := prompt(reader, "Use existing certificates? (yes/no)", "yes")
		if strings.ToLower(useExisting) == "no" {
			certsExist = false
		}
	}

	if !certsExist {
		genCerts := prompt(reader, "Generate new certificates? (yes/no)", "yes")
		if strings.ToLower(genCerts) == "yes" {
			fmt.Printf("Generating certificates in %s ...\n", certDir)
			if err := certs.Generate(certs.Options{
				Hostname:  hostname,
				OutputDir: certDir,
				Days:      1095,
				KeySize:   2048,
			}); err != nil {
				return fmt.Errorf("generate certs: %w", err)
			}
			fmt.Println("Certificates generated successfully!")
		} else {
			certFile = prompt(reader, "Path to server certificate", certFile)
			keyFile = prompt(reader, "Path to server private key", keyFile)
			caCertFile = prompt(reader, "Path to CA certificate", caCertFile)
		}
	}

	// --- Users ---
	fmt.Println()
	fmt.Println("--- User Configuration ---")
	var usersBlock strings.Builder
	for {
		addUser := prompt(reader, "Add a user? (yes/no)", "yes")
		if strings.ToLower(addUser) != "yes" {
			break
		}

		username := prompt(reader, "Username", "")
		if username == "" {
			fmt.Println("Username cannot be empty, skipping.")
			continue
		}

		secret, err := crypto.GenerateSecret()
		if err != nil {
			return fmt.Errorf("generate secret: %w", err)
		}
		fmt.Printf("  Generated secret for %s: %s\n", username, secret)

		usersBlock.WriteString(fmt.Sprintf(`
[[server.users]]
username = %q
secret = %q
whitelist = ["0.0.0.0/0"]
logging = true
`, username, secret))
	}

	if usersBlock.Len() == 0 {
		fmt.Println("Warning: No users configured. You can add users later with 'adduser' command.")
	}

	// --- Stealth ---
	fmt.Println()
	stealthEnabled := prompt(reader, "Enable stealth/DPI evasion? (yes/no)", "yes")

	// --- Generate config ---
	id := randomID()
	filename := fmt.Sprintf("config_%s.toml", id)

	config := fmt.Sprintf(`# SMTP Tunnel Server Configuration
# Generated by wizard

[server]
listen = %q
hostname = %q
cert_file = %q
key_file = %q
log_level = %q

[server.tls]
min_version = "1.2"
%s
[client]
server = "%s:587"
username = ""
secret = ""
ca_cert = %q
insecure_skip_verify = false
reconnect_delay = "2s"
max_reconnect_delay = "30s"

[[client.socks]]
listen = "127.0.0.1:1080"
username = ""
password = ""

[stealth]
enabled = %v
min_delay_ms = 50
max_delay_ms = 500
padding_sizes = [4096, 8192, 16384, 32768]
dummy_probability = 0.1
`, listen, hostname, certFile, keyFile, logLevel,
		usersBlock.String(), hostname, caCertFile,
		strings.ToLower(stealthEnabled) == "yes")

	if err := os.WriteFile(filename, []byte(config), 0644); err != nil {
		return fmt.Errorf("write config: %w", err)
	}

	fmt.Println()
	fmt.Printf("Configuration written to: %s\n", filename)
	fmt.Printf("CA certificate: %s\n", caCertFile)
	fmt.Println()
	fmt.Println("Next steps:")
	fmt.Printf("  1. Start server:  smtptunnel-server run -c %s\n", filename)
	fmt.Printf("  2. Or register:   smtptunnel-server service install %s\n", filename)
	fmt.Println("  3. Copy ca.crt to client machines for TLS verification")

	return nil
}

// RunClientWizard interactively generates a client configuration file.
func RunClientWizard() error {
	if err := EnsureDirectories(); err != nil {
		return err
	}

	reader := bufio.NewReader(os.Stdin)

	fmt.Println("=== SMTP Tunnel Client Configuration Wizard ===")
	fmt.Println()

	// Server
	server := prompt(reader, "Server address (host:port)", "")
	if server == "" {
		return fmt.Errorf("server address is required")
	}

	// Credentials
	username := prompt(reader, "Username", "")
	if username == "" {
		return fmt.Errorf("username is required")
	}
	secret := prompt(reader, "Secret", "")
	if secret == "" {
		return fmt.Errorf("secret is required")
	}

	// TLS
	fmt.Println()
	fmt.Println("--- TLS Settings ---")
	caCert := prompt(reader, "Path to CA certificate (or 'skip' for insecure)", "ca.crt")
	insecure := false
	if caCert == "skip" {
		insecure = true
		caCert = ""
	}

	// --- SOCKS proxies ---
	fmt.Println()
	fmt.Println("--- Local Proxies ---")
	var socksBlock strings.Builder
	for {
		addSocks := prompt(reader, "Add a SOCKS5 proxy? (yes/no)", "yes")
		if strings.ToLower(addSocks) != "yes" {
			break
		}
		socksListen := prompt(reader, "SOCKS5 listen address", "127.0.0.1:1080")
		socksUser := prompt(reader, "SOCKS5 username (empty for none)", "")
		socksPass := ""
		if socksUser != "" {
			socksPass = prompt(reader, "SOCKS5 password", "")
		}

		socksBlock.WriteString(fmt.Sprintf(`
[[client.socks]]
listen = %q
username = %q
password = %q
`, socksListen, socksUser, socksPass))
	}

	// --- Forward rules ---
	var forwardBlock strings.Builder
	for {
		addFwd := prompt(reader, "Add a port forward rule? (yes/no)", "no")
		if strings.ToLower(addFwd) != "yes" {
			break
		}
		fwdListen := prompt(reader, "Local listen address (e.g., 127.0.0.1:8080)", "")
		fwdTarget := prompt(reader, "Remote forward target (e.g., internal:80)", "")
		fwdProto := prompt(reader, "Protocol (tcp/udp)", "tcp")

		forwardBlock.WriteString(fmt.Sprintf(`
[[client.forward]]
listen = %q
forward = %q
protocol = %q
`, fwdListen, fwdTarget, fwdProto))
	}

	if socksBlock.Len() == 0 && forwardBlock.Len() == 0 {
		// Default SOCKS entry
		socksBlock.WriteString(`
[[client.socks]]
listen = "127.0.0.1:1080"
username = ""
password = ""
`)
	}

	// --- Stealth ---
	fmt.Println()
	stealthEnabled := prompt(reader, "Enable stealth/DPI evasion? (yes/no)", "yes")

	// --- Generate ---
	id := randomID()
	filename := fmt.Sprintf("config_%s.toml", id)

	insecureStr := "false"
	if insecure {
		insecureStr = "true"
	}

	config := fmt.Sprintf(`# SMTP Tunnel Client Configuration
# Generated by wizard

[client]
server = %q
username = %q
secret = %q
ca_cert = %q
insecure_skip_verify = %s
reconnect_delay = "2s"
max_reconnect_delay = "30s"
%s%s
[stealth]
enabled = %v
min_delay_ms = 50
max_delay_ms = 500
padding_sizes = [4096, 8192, 16384, 32768]
dummy_probability = 0.1
`, server, username, secret, caCert, insecureStr,
		socksBlock.String(), forwardBlock.String(),
		strings.ToLower(stealthEnabled) == "yes")

	if err := os.WriteFile(filename, []byte(config), 0644); err != nil {
		return fmt.Errorf("write config: %w", err)
	}

	fmt.Println()
	fmt.Printf("Configuration written to: %s\n", filename)
	fmt.Println()
	fmt.Println("Next steps:")
	fmt.Printf("  1. Start client:  smtptunnel-client run -c %s\n", filename)
	fmt.Printf("  2. Or register:   smtptunnel-client service install %s\n", filename)

	return nil
}

func prompt(reader *bufio.Reader, question, defaultVal string) string {
	if defaultVal != "" {
		fmt.Printf("%s [%s]: ", question, defaultVal)
	} else {
		fmt.Printf("%s: ", question)
	}

	line, _ := reader.ReadString('\n')
	line = strings.TrimSpace(line)
	if line == "" {
		return defaultVal
	}
	return line
}

func randomID() string {
	b := make([]byte, 4)
	rand.Read(b)
	return hex.EncodeToString(b)
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}
